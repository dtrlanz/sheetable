<script>
// Compiled using undefined undefined (TypeScript 4.9.5)
"use strict";
function sheetableClient(Constructor) {
    const meta = (new Constructor())[META];
    const indexKey = meta?.index;
    const indexLabel = indexKey ? meta?.props.get(indexKey)?.label : undefined;
    return class ClientTable extends Table {
        constructor(data) {
            let maxColLen = 0;
            for (const col of data.columns) {
                if (col && col.length > maxColLen)
                    maxColLen = col.length;
            }
            const dataRowStart = getMaxRow({ row: 1, children: data.headers }) + 1;
            const headers = getHeaderTree(new Constructor(), data.headers, dataRowStart);
            if (headers === undefined)
                throw new Error('failed to parse headers');
            super(Constructor, headers, maxColLen + 1, dataRowStart);
            this.sheetInfo = data;
            this.colData = data;
            this.includeCols = [];
            for (const c of this.headers.children) {
                for (let i = c.colStart; i < c.colStop; i++)
                    this.includeCols.push(i);
            }
            this.initIndex();
        }
        static open(sheet, columnLabels) {
            let successHandler = function () { };
            let failureHandle;
            const promise = new Promise((res, rej) => {
                successHandler = function (data) {
                    const table = new ClientTable(data);
                    res(table);
                };
                failureHandle = function (e) {
                    rej(e);
                };
            });
            columnLabels ?? (columnLabels = typeof indexLabel === 'string' ? [indexLabel] : []);
            google.script.run
                .withSuccessHandler(successHandler)
                .withFailureHandler((e) => log('failed to open table: ' + String(e)))
                .getSheetData(sheet, columnLabels, 1);
            return promise;
        }
        readRow(row, checkState) {
            return this.colData.columns.map(col => col?.[row - this.colData.rowOffset]);
        }
        ;
        writeRow(row, vals, checkState) {
            writeSheetRow(this.sheetInfo, row, vals, checkState);
        }
        fetchData(rowStart, rowStop) {
            let successHandler = function () { };
            let failureHandle;
            const captureThis = this;
            const promise = new Promise((res, rej) => {
                successHandler = function (data) {
                    captureThis.colData = data;
                    rowStop ?? (rowStop = captureThis.dataRowStop);
                    for (let i = rowStart - captureThis.dataRowStart; i < rowStop - captureThis.dataRowStart; i++) {
                        delete captureThis.cache[i];
                    }
                    res();
                };
                failureHandle = function (e) {
                    rej(e);
                };
            });
            google.script.run
                .withSuccessHandler(successHandler)
                .withFailureHandler((e) => log('failed to open table: ' + String(e)))
                .getSheetColumns(this.sheetInfo, this.includeCols, rowStart, rowStop);
            return promise;
        }
    };
}



// Compiled using undefined undefined (TypeScript 4.9.5)
"use strict";
// Code used both server-side and client-side
const META = Symbol('sheetable metadata');
class Table {
    constructor(ctor, headers, dataRowStop, dataRowStart) {
        this.cache = [];
        this.index = new Map();
        this.ctor = ctor;
        this.indexKey = ctor.prototype[META].index;
        this.headers = headers;
        this.dataRowStart = dataRowStart ?? getMaxRow(this.headers) + 1;
        this.dataRowStop = dataRowStop;
    }
    initIndex() {
        if (!this.indexKey)
            return;
        this.index.clear();
        for (let row = this.dataRowStart; row < this.dataRowStop; row++) {
            const entry = this.getRow(row);
            if (entry?.[this.indexKey])
                this.index.set(String(entry[this.indexKey]), row);
        }
    }
    getRow(row, refresh) {
        const cached = this.cache[row - this.dataRowStart];
        if (cached && !refresh)
            return cached;
        const vals = this.readRow(row);
        if (!vals)
            return undefined;
        const obj = new this.ctor();
        applyRowValues(obj, vals, this.headers);
        this.cache[row - this.dataRowStart] = obj;
        return obj;
    }
    setRow(row, entry) {
        // get or create row
        const obj = this.getRow(row) ?? (this.cache[row - this.dataRowStart] = new this.ctor());
        // update row
        assignDeep(entry, obj);
        // write row to sheet
        const vals = [];
        fillRowValues(obj, vals, this.headers);
        this.writeRow(row, vals);
    }
    get(idx, refresh) {
        const strIdx = typeof idx === 'string' ? idx : this.getIndex(idx);
        if (strIdx === undefined)
            return undefined;
        const row = this.index.get(strIdx);
        if (row === undefined)
            return undefined;
        return this.getRow(row, refresh);
    }
    set(idx, entry) {
        const strIdx = typeof idx === 'string' ? idx : this.getIndex(idx);
        if (strIdx === undefined) {
            throw new Error(`Index property '${this.indexKey}' not found in ${JSON.stringify(idx)}.`);
        }
        entry ?? (entry = typeof idx === 'object' ? idx : {});
        const row = this.index.get(strIdx) ?? this.dataRowStop;
        this.setRow(row, entry);
        this.index.set(strIdx, row);
    }
    getIndex(entry) {
        if (!this.indexKey)
            return undefined;
        const field = entry[this.indexKey];
        if (field !== undefined)
            return String(field);
        return undefined;
    }
}
function applyRowValues(target, row, headers) {
    if (headers.children.length === 0 && 'key' in headers) {
        const val = row[headers.colStart - 1];
        if (typeof headers.key === 'string') {
            if (headers.key in target) {
                applyValue(target, headers.key, val);
            }
        }
        else {
            if (Array.isArray(target[headers.key[0]])) {
                applyValue(target[headers.key[0]], headers.key[1], val);
            }
        }
    }
    else {
        let obj = target;
        if ('key' in headers) {
            if (typeof headers.key === 'string') {
                obj = target[headers.key];
            }
            else {
                obj = target[headers.key[0]][headers.key[1]];
            }
        }
        for (const c of headers.children) {
            applyRowValues(obj, row, c);
        }
    }
}
function applyValue(target, propertyKey, val) {
    if (val === undefined)
        return;
    if (typeof target[propertyKey] === 'number' && typeof val === 'number') {
        target[propertyKey] = val;
    }
    else if (typeof target[propertyKey] === 'string') {
        target[propertyKey] = String(val);
    }
}
function fillRowValues(source, row, headers) {
    if (headers.children.length === 0 && 'key' in headers) {
        let val;
        if (typeof headers.key === 'string') {
            val = source[headers.key];
        }
        else {
            val = source[headers.key[0]][headers.key[1]];
        }
        if (val !== undefined)
            row[headers.colStart - 1] = val;
    }
    else {
        let obj = source;
        if ('key' in headers) {
            if (typeof headers.key === 'string') {
                obj = source[headers.key];
            }
            else {
                obj = source[headers.key[0]][headers.key[1]];
            }
        }
        for (const c of headers.children) {
            fillRowValues(obj, row, c);
        }
    }
}
function assignDeep(source, target) {
    for (const k in source) {
        if (typeof source[k] === 'object' && !(source[k] instanceof Date)) {
            if (!target[k] || typeof target[k] !== 'object')
                target[k] = {};
            assignDeep(source[k], target[k]);
            continue;
        }
        target[k] = source[k];
    }
}
function getHeaderTree(obj, branches, rowStop) {
    // ui.alert(`branch labels: ${branches.map(b=>b.label).join(', ')}`);
    if (branches.length === 0 || branches[0].row >= rowStop)
        return undefined;
    const root = {
        colStart: branches[0].start,
        colStop: branches[branches.length - 1].stop,
        row: branches[0].row,
        children: [],
    };
    for (const b of branches) {
        let key;
        key = labelToKey(obj, b.label);
        let item;
        if (typeof key === 'string') {
            if (obj[key] === undefined) {
                const init = obj[META]?.props.get(key)?.init;
                if (init) {
                    obj[key] = init();
                }
            }
            item = obj[key];
        }
        else {
            const [k, i] = key;
            obj[k] ?? (obj[k] = []);
            if (obj[k][i] === undefined) {
                const init = obj[META]?.props.get(k)?.init;
                if (init) {
                    obj[k][i] = init();
                }
            }
            item = obj[k][i];
        }
        const node = {
            row: b.row,
            colStart: b.start,
            colStop: b.stop,
            children: [],
            parent: root,
            key: key,
            label: b.label,
        };
        const hn = getHeaderTree(item ?? {}, b.children, rowStop);
        if (hn) {
            node.children = hn.children.map(child => ({ ...child, parent: node }));
        }
        root.children.push(node);
    }
    return root;
}
function getMaxRow(headers) {
    return Math.max(headers.row, ...headers.children.map(c => getMaxRow(c)));
}
function label(value) {
    return function (target, propertyKey) {
        const l2k = configureProp(target, propertyKey, { label: value }).labelToKey;
        if (typeof value === 'string') {
            l2k.set(value, propertyKey);
        }
        else {
            for (let i = 0; i < value.length; i++) {
                l2k.set(value[i], [propertyKey, i]);
            }
        }
    };
}
function index(target, propertyKey) {
    if (target[META]) {
        target[META].index = propertyKey;
        return;
    }
    target[META] = {
        props: new Map(),
        labelToKey: new Map(),
        index: propertyKey,
    };
}
function configureProp(target, propertyKey, options) {
    if (target[META] === undefined) {
        target[META] = {
            props: new Map(),
            labelToKey: new Map(),
        };
    }
    let prop = target[META].props.get(propertyKey);
    if (!prop) {
        target[META].props.set(propertyKey, options);
    }
    else {
        for (const k in options) {
            prop[k] = options[k];
        }
    }
    return target[META];
}
function labelToKey(obj, label) {
    return obj[META]?.labelToKey.get(String(label)) ?? String(label);
}


</script>